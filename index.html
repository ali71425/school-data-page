
<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª - Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹Ø§Ù…Ø© Ù„Ù„ØªØ¹Ù„ÙŠÙ…</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js">
    function exportPDF() {
      const chartsContainer = document.querySelector('.container');
      html2canvas(chartsContainer, { scale: 2 }).then(canvas => {
        const imgData = canvas.toDataURL('image/png');
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'mm', 'a4');
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const imgProps = pdf.getImageProperties(imgData);
        const pdfWidth = pageWidth * 0.95;
        const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;

        pdf.addImage(imgData, 'PNG', (pageWidth - pdfWidth) / 2, 10, pdfWidth, pdfHeight);
        pdf.save('Ù„ÙˆØ­Ø©-Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª.pdf');
      });
    }


function fillTables(data) {
  document.getElementById('tablesSection').style.display = 'block';
  const confirmed = [];
  const modified = [];
  const pending = [];

  data.forEach(row => {
    const status = row[9];
    const info = [row[4], row[1], row[5], row[6]];
    if (status === "ØªÙ… Ø§Ù„ØªØ£ÙƒÙŠØ¯") confirmed.push(info);
    else if (status === "Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©") modified.push(info);
    else pending.push(info);
  });

  const headers = ['Ø§Ø³Ù… Ø§Ù„Ù…Ø¯Ø±Ø³Ø©', 'Ø§Ù„Ù‚Ø·Ø§Ø¹', 'Ø§Ù„Ù…Ø¯ÙŠØ±/Ø©', 'Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆØ§Ù„'];
  createTable('confirmedTable', headers, confirmed);
  createTable('modifiedTable', headers, modified);
  createTable('pendingTable', headers, pending);
}

function createTable(id, headers, rows) {
  const table = document.getElementById(id);
  table.innerHTML = '';
  const thead = document.createElement('thead');
  const tr = document.createElement('tr');
  headers.forEach(h => {
    const th = document.createElement('th');
    th.textContent = h;
    tr.appendChild(th);
  });
  thead.appendChild(tr);
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  rows.forEach(row => {
    const tr = document.createElement('tr');
    row.forEach(cell => {
      const td = document.createElement('td');
      td.textContent = cell;
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
}

function exportTableTo(tableId, name, type) {
  const table = document.getElementById(tableId);
  if (type === 'pdf') {
    html2canvas(table).then(canvas => {
      const imgData = canvas.toDataURL('image/png');
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF();
      const title = "Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹Ø§Ù…Ø© Ù„Ù„ØªØ¹Ù„ÙŠÙ… Ø¨Ù…Ù†Ø·Ù‚Ø© Ø¹Ø³ÙŠØ± - Ù‚Ø³Ù… Ø§Ù„Ø£Ù…Ù† ÙˆØ§Ù„Ø³Ù„Ø§Ù…Ø© ÙˆØ§Ù„Ù…Ø±Ø§ÙÙ‚\nÙ‚Ø§Ø¦Ù…Ø©: " + document.querySelector('#' + tableId).previousElementSibling.previousElementSibling.textContent;
      pdf.setFontSize(14);
      pdf.text(title, 10, 10);
      const imgProps = pdf.getImageProperties(imgData);
      const pageWidth = pdf.internal.pageSize.getWidth() - 20;
      const pdfHeight = (imgProps.height * pageWidth) / imgProps.width;
      pdf.addImage(imgData, 'PNG', 10, 20, pageWidth, pdfHeight);
      pdf.save(name + '.pdf');
    });
  } else {
    let csv = '';
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      const cols = row.querySelectorAll('td, th');
      csv += Array.from(cols).map(col => `"${col.textContent}"`).join(',') + '\n';
    });
    const blob = new Blob([csv], { type: 'text/csv' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = name + '.csv';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
}


function fillTables(data) {
  document.getElementById('tablesSection').style.display = 'block';
  const confirmed = [];
  const modified = [];
  const pending = [];

  data.forEach(row => {
    const status = row[9];
    const info = [row[4], row[1], row[5], row[6]];
    if (status === "ØªÙ… Ø§Ù„ØªØ£ÙƒÙŠØ¯") confirmed.push(info);
    else if (status === "Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©") modified.push(info);
    else pending.push(info);
  });

  const headers = ['#', 'Ø§Ø³Ù… Ø§Ù„Ù…Ø¯Ø±Ø³Ø©', 'Ø§Ù„Ù‚Ø·Ø§Ø¹', 'Ø§Ù„Ù…Ø¯ÙŠØ±/Ø©', 'Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆØ§Ù„'];
  createTable('confirmedTable', headers, confirmed);
  createTable('modifiedTable', headers, modified);
  createTable('pendingTable', headers, pending);

  document.getElementById("countConfirmed").textContent = "Ø§Ù„Ø¹Ø¯Ø¯: " + confirmed.length;
  document.getElementById("countModified").textContent = "Ø§Ù„Ø¹Ø¯Ø¯: " + modified.length;
  document.getElementById("countPending").textContent = "Ø§Ù„Ø¹Ø¯Ø¯: " + pending.length;
}

function createTable(id, headers, rows) {
  const table = document.getElementById(id);
  table.innerHTML = '';
  const thead = document.createElement('thead');
  const tr = document.createElement('tr');
  headers.forEach(h => {
    const th = document.createElement('th');
    th.textContent = h;
    tr.appendChild(th);
  });
  thead.appendChild(tr);
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  rows.forEach((row, idx) => {
    const tr = document.createElement('tr');
    const tdIndex = document.createElement('td');
    tdIndex.textContent = idx + 1;
    tr.appendChild(tdIndex);
    row.forEach(cell => {
      const td = document.createElement('td');
      td.textContent = cell;
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
}

</script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels">
    function exportPDF() {
      const chartsContainer = document.querySelector('.container');
      html2canvas(chartsContainer, { scale: 2 }).then(canvas => {
        const imgData = canvas.toDataURL('image/png');
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'mm', 'a4');
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const imgProps = pdf.getImageProperties(imgData);
        const pdfWidth = pageWidth * 0.95;
        const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;

        pdf.addImage(imgData, 'PNG', (pageWidth - pdfWidth) / 2, 10, pdfWidth, pdfHeight);
        pdf.save('Ù„ÙˆØ­Ø©-Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª.pdf');
      });
    }


function fillTables(data) {
  document.getElementById('tablesSection').style.display = 'block';
  const confirmed = [];
  const modified = [];
  const pending = [];

  data.forEach(row => {
    const status = row[9];
    const info = [row[4], row[1], row[5], row[6]];
    if (status === "ØªÙ… Ø§Ù„ØªØ£ÙƒÙŠØ¯") confirmed.push(info);
    else if (status === "Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©") modified.push(info);
    else pending.push(info);
  });

  const headers = ['Ø§Ø³Ù… Ø§Ù„Ù…Ø¯Ø±Ø³Ø©', 'Ø§Ù„Ù‚Ø·Ø§Ø¹', 'Ø§Ù„Ù…Ø¯ÙŠØ±/Ø©', 'Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆØ§Ù„'];
  createTable('confirmedTable', headers, confirmed);
  createTable('modifiedTable', headers, modified);
  createTable('pendingTable', headers, pending);
}

function createTable(id, headers, rows) {
  const table = document.getElementById(id);
  table.innerHTML = '';
  const thead = document.createElement('thead');
  const tr = document.createElement('tr');
  headers.forEach(h => {
    const th = document.createElement('th');
    th.textContent = h;
    tr.appendChild(th);
  });
  thead.appendChild(tr);
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  rows.forEach(row => {
    const tr = document.createElement('tr');
    row.forEach(cell => {
      const td = document.createElement('td');
      td.textContent = cell;
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
}

function exportTableTo(tableId, name, type) {
  const table = document.getElementById(tableId);
  if (type === 'pdf') {
    html2canvas(table).then(canvas => {
      const imgData = canvas.toDataURL('image/png');
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF();
      const title = "Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹Ø§Ù…Ø© Ù„Ù„ØªØ¹Ù„ÙŠÙ… Ø¨Ù…Ù†Ø·Ù‚Ø© Ø¹Ø³ÙŠØ± - Ù‚Ø³Ù… Ø§Ù„Ø£Ù…Ù† ÙˆØ§Ù„Ø³Ù„Ø§Ù…Ø© ÙˆØ§Ù„Ù…Ø±Ø§ÙÙ‚\nÙ‚Ø§Ø¦Ù…Ø©: " + document.querySelector('#' + tableId).previousElementSibling.previousElementSibling.textContent;
      pdf.setFontSize(14);
      pdf.text(title, 10, 10);
      const imgProps = pdf.getImageProperties(imgData);
      const pageWidth = pdf.internal.pageSize.getWidth() - 20;
      const pdfHeight = (imgProps.height * pageWidth) / imgProps.width;
      pdf.addImage(imgData, 'PNG', 10, 20, pageWidth, pdfHeight);
      pdf.save(name + '.pdf');
    });
  } else {
    let csv = '';
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      const cols = row.querySelectorAll('td, th');
      csv += Array.from(cols).map(col => `"${col.textContent}"`).join(',') + '\n';
    });
    const blob = new Blob([csv], { type: 'text/csv' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = name + '.csv';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
}


function fillTables(data) {
  document.getElementById('tablesSection').style.display = 'block';
  const confirmed = [];
  const modified = [];
  const pending = [];

  data.forEach(row => {
    const status = row[9];
    const info = [row[4], row[1], row[5], row[6]];
    if (status === "ØªÙ… Ø§Ù„ØªØ£ÙƒÙŠØ¯") confirmed.push(info);
    else if (status === "Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©") modified.push(info);
    else pending.push(info);
  });

  const headers = ['#', 'Ø§Ø³Ù… Ø§Ù„Ù…Ø¯Ø±Ø³Ø©', 'Ø§Ù„Ù‚Ø·Ø§Ø¹', 'Ø§Ù„Ù…Ø¯ÙŠØ±/Ø©', 'Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆØ§Ù„'];
  createTable('confirmedTable', headers, confirmed);
  createTable('modifiedTable', headers, modified);
  createTable('pendingTable', headers, pending);

  document.getElementById("countConfirmed").textContent = "Ø§Ù„Ø¹Ø¯Ø¯: " + confirmed.length;
  document.getElementById("countModified").textContent = "Ø§Ù„Ø¹Ø¯Ø¯: " + modified.length;
  document.getElementById("countPending").textContent = "Ø§Ù„Ø¹Ø¯Ø¯: " + pending.length;
}

function createTable(id, headers, rows) {
  const table = document.getElementById(id);
  table.innerHTML = '';
  const thead = document.createElement('thead');
  const tr = document.createElement('tr');
  headers.forEach(h => {
    const th = document.createElement('th');
    th.textContent = h;
    tr.appendChild(th);
  });
  thead.appendChild(tr);
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  rows.forEach((row, idx) => {
    const tr = document.createElement('tr');
    const tdIndex = document.createElement('td');
    tdIndex.textContent = idx + 1;
    tr.appendChild(tdIndex);
    row.forEach(cell => {
      const td = document.createElement('td');
      td.textContent = cell;
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
}

</script>
  <style>
    body {
      font-family: 'Cairo', sans-serif;
      background-color: #f0f4f8;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    header {
      background-color: #006c35;
      color: white;
      text-align: center;
      padding: 10px 20px;
    }

    .container {
      display: flex;
      gap: 20px;
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: space-around;
      align-items: flex-start;
      max-width: 1200px;
      width: 100%;
      background: white;
      border-radius: 10px;
      padding: 10px 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      margin-top: 20px;
    }

    .card {
      background-color: #ffffff;
      border-radius: 12px;
      padding: 15px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      margin-bottom: 20px;
      width: 100%;
      max-width: 400px;
    }

    h2 {
      text-align: center;
      margin-bottom: 20px;
    }

    canvas {
      max-width: 100%;
    }

    @media (max-width: 768px) {
      .container {
        flex-direction: column;
        align-items: center;
      }
    }
  
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      font-size: 15px;
    }
    table thead {
      background-color: #006c35;
      color: white;
    }
    table th, table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
    }
    table tr:nth-child(even) {
      background-color: #f2f2f2;
    }
    table tr:hover {
      background-color: #ddd;
    }
    .card h3 {
      margin-bottom: 10px;
      font-size: 18px;
      color: #006c35;
    }


    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      font-size: 14px;
    }
    table thead {
      background-color: #006c35;
      color: white;
    }
    table th, table td {
      border: 1px solid #ddd;
      padding: 6px 10px;
      text-align: center;
    }
    table tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    table tr:hover {
      background-color: #e0f2e9;
    }
    .card {
      width: 100%;
      margin-bottom: 30px;
      padding: 20px;
      border-radius: 10px;
      background-color: #ffffff;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
    }
    .card h3 {
      font-size: 18px;
      margin-bottom: 10px;
      color: #006c35;
    }
    .card .counter {
      font-size: 14px;
      color: #555;
      margin-bottom: 10px;
    }
    .card button {
      margin-left: 5px;
      font-size: 13px;
      padding: 5px 10px;
      border-radius: 4px;
      border: none;
      background-color: #006c35;
      color: white;
      cursor: pointer;
    }

</style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js">
    function exportPDF() {
      const chartsContainer = document.querySelector('.container');
      html2canvas(chartsContainer, { scale: 2 }).then(canvas => {
        const imgData = canvas.toDataURL('image/png');
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'mm', 'a4');
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const imgProps = pdf.getImageProperties(imgData);
        const pdfWidth = pageWidth * 0.95;
        const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;

        pdf.addImage(imgData, 'PNG', (pageWidth - pdfWidth) / 2, 10, pdfWidth, pdfHeight);
        pdf.save('Ù„ÙˆØ­Ø©-Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª.pdf');
      });
    }


function fillTables(data) {
  document.getElementById('tablesSection').style.display = 'block';
  const confirmed = [];
  const modified = [];
  const pending = [];

  data.forEach(row => {
    const status = row[9];
    const info = [row[4], row[1], row[5], row[6]];
    if (status === "ØªÙ… Ø§Ù„ØªØ£ÙƒÙŠØ¯") confirmed.push(info);
    else if (status === "Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©") modified.push(info);
    else pending.push(info);
  });

  const headers = ['Ø§Ø³Ù… Ø§Ù„Ù…Ø¯Ø±Ø³Ø©', 'Ø§Ù„Ù‚Ø·Ø§Ø¹', 'Ø§Ù„Ù…Ø¯ÙŠØ±/Ø©', 'Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆØ§Ù„'];
  createTable('confirmedTable', headers, confirmed);
  createTable('modifiedTable', headers, modified);
  createTable('pendingTable', headers, pending);
}

function createTable(id, headers, rows) {
  const table = document.getElementById(id);
  table.innerHTML = '';
  const thead = document.createElement('thead');
  const tr = document.createElement('tr');
  headers.forEach(h => {
    const th = document.createElement('th');
    th.textContent = h;
    tr.appendChild(th);
  });
  thead.appendChild(tr);
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  rows.forEach(row => {
    const tr = document.createElement('tr');
    row.forEach(cell => {
      const td = document.createElement('td');
      td.textContent = cell;
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
}

function exportTableTo(tableId, name, type) {
  const table = document.getElementById(tableId);
  if (type === 'pdf') {
    html2canvas(table).then(canvas => {
      const imgData = canvas.toDataURL('image/png');
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF();
      const title = "Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹Ø§Ù…Ø© Ù„Ù„ØªØ¹Ù„ÙŠÙ… Ø¨Ù…Ù†Ø·Ù‚Ø© Ø¹Ø³ÙŠØ± - Ù‚Ø³Ù… Ø§Ù„Ø£Ù…Ù† ÙˆØ§Ù„Ø³Ù„Ø§Ù…Ø© ÙˆØ§Ù„Ù…Ø±Ø§ÙÙ‚\nÙ‚Ø§Ø¦Ù…Ø©: " + document.querySelector('#' + tableId).previousElementSibling.previousElementSibling.textContent;
      pdf.setFontSize(14);
      pdf.text(title, 10, 10);
      const imgProps = pdf.getImageProperties(imgData);
      const pageWidth = pdf.internal.pageSize.getWidth() - 20;
      const pdfHeight = (imgProps.height * pageWidth) / imgProps.width;
      pdf.addImage(imgData, 'PNG', 10, 20, pageWidth, pdfHeight);
      pdf.save(name + '.pdf');
    });
  } else {
    let csv = '';
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      const cols = row.querySelectorAll('td, th');
      csv += Array.from(cols).map(col => `"${col.textContent}"`).join(',') + '\n';
    });
    const blob = new Blob([csv], { type: 'text/csv' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = name + '.csv';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
}


function fillTables(data) {
  document.getElementById('tablesSection').style.display = 'block';
  const confirmed = [];
  const modified = [];
  const pending = [];

  data.forEach(row => {
    const status = row[9];
    const info = [row[4], row[1], row[5], row[6]];
    if (status === "ØªÙ… Ø§Ù„ØªØ£ÙƒÙŠØ¯") confirmed.push(info);
    else if (status === "Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©") modified.push(info);
    else pending.push(info);
  });

  const headers = ['#', 'Ø§Ø³Ù… Ø§Ù„Ù…Ø¯Ø±Ø³Ø©', 'Ø§Ù„Ù‚Ø·Ø§Ø¹', 'Ø§Ù„Ù…Ø¯ÙŠØ±/Ø©', 'Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆØ§Ù„'];
  createTable('confirmedTable', headers, confirmed);
  createTable('modifiedTable', headers, modified);
  createTable('pendingTable', headers, pending);

  document.getElementById("countConfirmed").textContent = "Ø§Ù„Ø¹Ø¯Ø¯: " + confirmed.length;
  document.getElementById("countModified").textContent = "Ø§Ù„Ø¹Ø¯Ø¯: " + modified.length;
  document.getElementById("countPending").textContent = "Ø§Ù„Ø¹Ø¯Ø¯: " + pending.length;
}

function createTable(id, headers, rows) {
  const table = document.getElementById(id);
  table.innerHTML = '';
  const thead = document.createElement('thead');
  const tr = document.createElement('tr');
  headers.forEach(h => {
    const th = document.createElement('th');
    th.textContent = h;
    tr.appendChild(th);
  });
  thead.appendChild(tr);
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  rows.forEach((row, idx) => {
    const tr = document.createElement('tr');
    const tdIndex = document.createElement('td');
    tdIndex.textContent = idx + 1;
    tr.appendChild(tdIndex);
    row.forEach(cell => {
      const td = document.createElement('td');
      td.textContent = cell;
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
}

</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js">
    function exportPDF() {
      const chartsContainer = document.querySelector('.container');
      html2canvas(chartsContainer, { scale: 2 }).then(canvas => {
        const imgData = canvas.toDataURL('image/png');
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'mm', 'a4');
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const imgProps = pdf.getImageProperties(imgData);
        const pdfWidth = pageWidth * 0.95;
        const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;

        pdf.addImage(imgData, 'PNG', (pageWidth - pdfWidth) / 2, 10, pdfWidth, pdfHeight);
        pdf.save('Ù„ÙˆØ­Ø©-Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª.pdf');
      });
    }


function fillTables(data) {
  document.getElementById('tablesSection').style.display = 'block';
  const confirmed = [];
  const modified = [];
  const pending = [];

  data.forEach(row => {
    const status = row[9];
    const info = [row[4], row[1], row[5], row[6]];
    if (status === "ØªÙ… Ø§Ù„ØªØ£ÙƒÙŠØ¯") confirmed.push(info);
    else if (status === "Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©") modified.push(info);
    else pending.push(info);
  });

  const headers = ['Ø§Ø³Ù… Ø§Ù„Ù…Ø¯Ø±Ø³Ø©', 'Ø§Ù„Ù‚Ø·Ø§Ø¹', 'Ø§Ù„Ù…Ø¯ÙŠØ±/Ø©', 'Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆØ§Ù„'];
  createTable('confirmedTable', headers, confirmed);
  createTable('modifiedTable', headers, modified);
  createTable('pendingTable', headers, pending);
}

function createTable(id, headers, rows) {
  const table = document.getElementById(id);
  table.innerHTML = '';
  const thead = document.createElement('thead');
  const tr = document.createElement('tr');
  headers.forEach(h => {
    const th = document.createElement('th');
    th.textContent = h;
    tr.appendChild(th);
  });
  thead.appendChild(tr);
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  rows.forEach(row => {
    const tr = document.createElement('tr');
    row.forEach(cell => {
      const td = document.createElement('td');
      td.textContent = cell;
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
}

function exportTableTo(tableId, name, type) {
  const table = document.getElementById(tableId);
  if (type === 'pdf') {
    html2canvas(table).then(canvas => {
      const imgData = canvas.toDataURL('image/png');
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF();
      const title = "Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹Ø§Ù…Ø© Ù„Ù„ØªØ¹Ù„ÙŠÙ… Ø¨Ù…Ù†Ø·Ù‚Ø© Ø¹Ø³ÙŠØ± - Ù‚Ø³Ù… Ø§Ù„Ø£Ù…Ù† ÙˆØ§Ù„Ø³Ù„Ø§Ù…Ø© ÙˆØ§Ù„Ù…Ø±Ø§ÙÙ‚\nÙ‚Ø§Ø¦Ù…Ø©: " + document.querySelector('#' + tableId).previousElementSibling.previousElementSibling.textContent;
      pdf.setFontSize(14);
      pdf.text(title, 10, 10);
      const imgProps = pdf.getImageProperties(imgData);
      const pageWidth = pdf.internal.pageSize.getWidth() - 20;
      const pdfHeight = (imgProps.height * pageWidth) / imgProps.width;
      pdf.addImage(imgData, 'PNG', 10, 20, pageWidth, pdfHeight);
      pdf.save(name + '.pdf');
    });
  } else {
    let csv = '';
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      const cols = row.querySelectorAll('td, th');
      csv += Array.from(cols).map(col => `"${col.textContent}"`).join(',') + '\n';
    });
    const blob = new Blob([csv], { type: 'text/csv' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = name + '.csv';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
}


function fillTables(data) {
  document.getElementById('tablesSection').style.display = 'block';
  const confirmed = [];
  const modified = [];
  const pending = [];

  data.forEach(row => {
    const status = row[9];
    const info = [row[4], row[1], row[5], row[6]];
    if (status === "ØªÙ… Ø§Ù„ØªØ£ÙƒÙŠØ¯") confirmed.push(info);
    else if (status === "Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©") modified.push(info);
    else pending.push(info);
  });

  const headers = ['#', 'Ø§Ø³Ù… Ø§Ù„Ù…Ø¯Ø±Ø³Ø©', 'Ø§Ù„Ù‚Ø·Ø§Ø¹', 'Ø§Ù„Ù…Ø¯ÙŠØ±/Ø©', 'Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆØ§Ù„'];
  createTable('confirmedTable', headers, confirmed);
  createTable('modifiedTable', headers, modified);
  createTable('pendingTable', headers, pending);

  document.getElementById("countConfirmed").textContent = "Ø§Ù„Ø¹Ø¯Ø¯: " + confirmed.length;
  document.getElementById("countModified").textContent = "Ø§Ù„Ø¹Ø¯Ø¯: " + modified.length;
  document.getElementById("countPending").textContent = "Ø§Ù„Ø¹Ø¯Ø¯: " + pending.length;
}

function createTable(id, headers, rows) {
  const table = document.getElementById(id);
  table.innerHTML = '';
  const thead = document.createElement('thead');
  const tr = document.createElement('tr');
  headers.forEach(h => {
    const th = document.createElement('th');
    th.textContent = h;
    tr.appendChild(th);
  });
  thead.appendChild(tr);
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  rows.forEach((row, idx) => {
    const tr = document.createElement('tr');
    const tdIndex = document.createElement('td');
    tdIndex.textContent = idx + 1;
    tr.appendChild(tdIndex);
    row.forEach(cell => {
      const td = document.createElement('td');
      td.textContent = cell;
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
}

</script>

</head>
<body>
  <header style='border-radius: 0; width: 100%;'>
    <h1>Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹Ø§Ù…Ø© Ù„Ù„ØªØ¹Ù„ÙŠÙ… Ø¨Ù…Ù†Ø·Ù‚Ø© Ø¹Ø³ÙŠØ±</h1>
    <h3>Ù‚Ø³Ù… Ø§Ù„Ø£Ù…Ù† ÙˆØ§Ù„Ø³Ù„Ø§Ù…Ø© ÙˆØ§Ù„Ù…Ø±Ø§ÙÙ‚</h3>
  </header>

  <div class="container">
    <h2>ğŸ“Š Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª</h2>
    <label for="sectorSelect">Ø§Ø®ØªØ± Ù‚Ø·Ø§Ø¹Ù‹Ø§ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:</label>
    <select id="sectorSelect">
      <option value="all">ÙƒÙ„ Ø§Ù„Ù‚Ø·Ø§Ø¹Ø§Øª</option>
    </select>
    <p id="summary"></p>
    <button onclick="exportPDF()" style="margin: 10px 0; padding: 10px 20px; background-color: #006c35; color: white; border: none; border-radius: 6px; font-size: 16px; cursor: pointer;">
      ğŸ“„ ØªØµØ¯ÙŠØ± Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª PDF
    </button>


    <div class="card"><canvas id="statusChart"></canvas></div>
    <div class="card"><canvas id="sectorChart"></canvas></div>
    <div class="card"><canvas id="barStatusChart"></canvas>
    <div id="tablesSection" style="display:none; width: 100%; margin-top: 30px;">
      <h2>ğŸ“‹ Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ù…Ø¯Ø§Ø±Ø³ Ø­Ø³Ø¨ Ø§Ù„ØªØµÙ†ÙŠÙ</h2>
      <div class="card">
        <h3>âœ… Ø§Ù„Ù…Ø¯Ø§Ø±Ø³ Ø§Ù„ØªÙŠ ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§ØªÙ‡Ø§</h3><div class="counter" id="countConfirmed"></div>
        <button onclick="exportTableTo('confirmedTable', 'confirmed', 'pdf')">ğŸ“„ ØªØµØ¯ÙŠØ± PDF</button>
        <button onclick="exportTableTo('confirmedTable', 'confirmed', 'excel')">ğŸ“¥ ØªØµØ¯ÙŠØ± Excel</button>
        <table id="confirmedTable"></table>
      </div>
      <div class="card">
        <h3>âš ï¸ Ø§Ù„Ù…Ø¯Ø§Ø±Ø³ Ø§Ù„ØªÙŠ Ø¹Ø¯Ù„Øª Ø¨ÙŠØ§Ù†Ø§ØªÙ‡Ø§</h3><div class="counter" id="countModified"></div>
        <button onclick="exportTableTo('modifiedTable', 'modified', 'pdf')">ğŸ“„ ØªØµØ¯ÙŠØ± PDF</button>
        <button onclick="exportTableTo('modifiedTable', 'modified', 'excel')">ğŸ“¥ ØªØµØ¯ÙŠØ± Excel</button>
        <table id="modifiedTable"></table>
      </div>
      <div class="card">
        <h3>âŒ Ø§Ù„Ù…Ø¯Ø§Ø±Ø³ Ø§Ù„ØªÙŠ Ù„Ù… ØªØ±Ø¯</h3><div class="counter" id="countPending"></div>
        <button onclick="exportTableTo('pendingTable', 'pending', 'pdf')">ğŸ“„ ØªØµØ¯ÙŠØ± PDF</button>
        <button onclick="exportTableTo('pendingTable', 'pending', 'excel')">ğŸ“¥ ØªØµØ¯ÙŠØ± Excel</button>
        <table id="pendingTable"></table>
      </div>
    </div>
</div>


  <script>
    // setInterval(() => location.reload(), 60000);
    const scriptURL = "https://script.google.com/macros/s/AKfycbyEHr9r1KLWmf-vCShIlFU7N_q69ZFws0mTu_3AbY-l1IqJTOvwNQaL2m8IeagGpFgo/exec?action=stats";

    fetch(scriptURL)
      .then(res => res.json())
      .then(data => {
        if (!data || !data.total || !data.sectors) throw new Error("Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± Ù…ÙƒØªÙ…Ù„Ø© Ø£Ùˆ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø©");

        document.getElementById("summary").textContent = `Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø¯Ø§Ø±Ø³: ${data.total}, Ø§Ù„Ù…Ø¤ÙƒØ¯Ø©: ${data.confirmed}, Ø§Ù„Ù…Ø¹Ø¯Ù„Ø©: ${data.modified}, Ù„Ù… ØªØ±Ø¯: ${data.pending}`;

        const commonOptions = {
          responsive: true,
          plugins: {
            legend: { position: 'bottom' },
            datalabels: {
              color: '#333',
              font: { weight: 'bold', size: 14 },
              formatter: value => value
            }
          },
          animation: {
            duration: 1500,
            easing: 'easeOutBounce'
          }
        };

        const statusChart = new Chart(document.getElementById("statusChart"), {
          type: 'doughnut',
          data: {
            labels: ['ØªÙ… Ø§Ù„ØªØ£ÙƒÙŠØ¯', 'Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©', 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø±Ø¯'],
            datasets: [{
              data: [data.confirmed, data.modified, data.pending],
              backgroundColor: ['#009966', '#ffca28', '#f44336']
            }]
          },
          options: {
            ...commonOptions,
            plugins: {
              ...commonOptions.plugins,
              title: {
                display: true,
                text: 'Ù†Ø³Ø¨Ø© Ø­Ø§Ù„Ø© ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',
                font: { size: 18 }
              }
            }
          },
          plugins: [ChartDataLabels]
        });

        const barStatusChart = new Chart(document.getElementById("barStatusChart"), {
          type: 'bar',
          data: {
            labels: ['ØªÙ… Ø§Ù„ØªØ£ÙƒÙŠØ¯', 'Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©', 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø±Ø¯'],
            datasets: [{
              label: 'Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø§Ù„Ø§Øª',
              data: [data.confirmed, data.modified, data.pending],
              backgroundColor: ['#009966', '#ffca28', '#f44336']
            }]
          },
          options: {
            ...commonOptions,
            plugins: {
              ...commonOptions.plugins,
              title: {
                display: true,
                text: 'Ù…Ø®Ø·Ø· Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',
                font: { size: 18 }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  stepSize: 1
                }
              }
            }
          },
          plugins: [ChartDataLabels]
        });

        const sectors = Object.keys(data.sectors);
        const values = Object.values(data.sectors);
        const select = document.getElementById("sectorSelect");

        sectors.forEach(sector => {
          const option = document.createElement("option");
          option.value = sector;
          option.textContent = sector;
          select.appendChild(option);
        });

        new Chart(document.getElementById("sectorChart"), {
          type: 'bar',
          data: {
            labels: sectors,
            datasets: [{
              label: 'Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¯Ø§Ø±Ø³',
              data: values,
              backgroundColor: '#006c35'
            }]
          },
          options: {
            ...commonOptions,
            indexAxis: 'y',
            plugins: {
              ...commonOptions.plugins,
              title: {
                display: true,
                text: 'ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…Ø¯Ø§Ø±Ø³ Ø­Ø³Ø¨ Ø§Ù„Ù‚Ø·Ø§Ø¹Ø§Øª',
                font: { size: 18 }
              }
            },
            scales: {
              x: {
                beginAtZero: true
              }
            }
          },
          plugins: [ChartDataLabels]
        });

        select.addEventListener("change", () => {
          const selectedSector = select.value;
          if (selectedSector === "all") {
            document.getElementById("summary").textContent = `Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø¯Ø§Ø±Ø³: ${data.total}, Ø§Ù„Ù…Ø¤ÙƒØ¯Ø©: ${data.confirmed}, Ø§Ù„Ù…Ø¹Ø¯Ù„Ø©: ${data.modified}, Ù„Ù… ØªØ±Ø¯: ${data.pending}`;
            statusChart.data.datasets[0].data = [data.confirmed, data.modified, data.pending];
            statusChart.update();
            fillTables(filtered);
            barStatusChart.data.datasets[0].data = [data.confirmed, data.modified, data.pending];
            barStatusChart.update();
          } else {
            const raw = data.raw || [];
            const filtered = raw.filter(row => row[1] === selectedSector);
            let total = filtered.length;
            let confirmed = filtered.filter(row => row[9] === "ØªÙ… Ø§Ù„ØªØ£ÙƒÙŠØ¯").length;
            let modified = filtered.filter(row => row[9] === "Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©").length;
            let pending = total - confirmed - modified;

            document.getElementById("summary").textContent = `Ø§Ù„Ù‚Ø·Ø§Ø¹: ${selectedSector} - Ø¥Ø¬Ù…Ø§Ù„ÙŠ: ${total}, Ø§Ù„Ù…Ø¤ÙƒØ¯Ø©: ${confirmed}, Ø§Ù„Ù…Ø¹Ø¯Ù„Ø©: ${modified}, Ù„Ù… ØªØ±Ø¯: ${pending}`;
            statusChart.data.datasets[0].data = [confirmed, modified, pending];
            statusChart.update();
            fillTables(filtered);
            barStatusChart.data.datasets[0].data = [confirmed, modified, pending];
            barStatusChart.update();
          }
        });
      })
      .catch(err => {
        document.getElementById("summary").textContent = 'ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø· Ø£Ùˆ Ø§Ù„Ø§ØªØµØ§Ù„.';
        console.error('Fetch error:', err);
      });
  
    function exportPDF() {
      const chartsContainer = document.querySelector('.container');
      html2canvas(chartsContainer, { scale: 2 }).then(canvas => {
        const imgData = canvas.toDataURL('image/png');
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'mm', 'a4');
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const imgProps = pdf.getImageProperties(imgData);
        const pdfWidth = pageWidth * 0.95;
        const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;

        pdf.addImage(imgData, 'PNG', (pageWidth - pdfWidth) / 2, 10, pdfWidth, pdfHeight);
        pdf.save('Ù„ÙˆØ­Ø©-Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª.pdf');
      });
    }


function fillTables(data) {
  document.getElementById('tablesSection').style.display = 'block';
  const confirmed = [];
  const modified = [];
  const pending = [];

  data.forEach(row => {
    const status = row[9];
    const info = [row[4], row[1], row[5], row[6]];
    if (status === "ØªÙ… Ø§Ù„ØªØ£ÙƒÙŠØ¯") confirmed.push(info);
    else if (status === "Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©") modified.push(info);
    else pending.push(info);
  });

  const headers = ['Ø§Ø³Ù… Ø§Ù„Ù…Ø¯Ø±Ø³Ø©', 'Ø§Ù„Ù‚Ø·Ø§Ø¹', 'Ø§Ù„Ù…Ø¯ÙŠØ±/Ø©', 'Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆØ§Ù„'];
  createTable('confirmedTable', headers, confirmed);
  createTable('modifiedTable', headers, modified);
  createTable('pendingTable', headers, pending);
}

function createTable(id, headers, rows) {
  const table = document.getElementById(id);
  table.innerHTML = '';
  const thead = document.createElement('thead');
  const tr = document.createElement('tr');
  headers.forEach(h => {
    const th = document.createElement('th');
    th.textContent = h;
    tr.appendChild(th);
  });
  thead.appendChild(tr);
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  rows.forEach(row => {
    const tr = document.createElement('tr');
    row.forEach(cell => {
      const td = document.createElement('td');
      td.textContent = cell;
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
}

function exportTableTo(tableId, name, type) {
  const table = document.getElementById(tableId);
  if (type === 'pdf') {
    html2canvas(table).then(canvas => {
      const imgData = canvas.toDataURL('image/png');
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF();
      const title = "Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹Ø§Ù…Ø© Ù„Ù„ØªØ¹Ù„ÙŠÙ… Ø¨Ù…Ù†Ø·Ù‚Ø© Ø¹Ø³ÙŠØ± - Ù‚Ø³Ù… Ø§Ù„Ø£Ù…Ù† ÙˆØ§Ù„Ø³Ù„Ø§Ù…Ø© ÙˆØ§Ù„Ù…Ø±Ø§ÙÙ‚\nÙ‚Ø§Ø¦Ù…Ø©: " + document.querySelector('#' + tableId).previousElementSibling.previousElementSibling.textContent;
      pdf.setFontSize(14);
      pdf.text(title, 10, 10);
      const imgProps = pdf.getImageProperties(imgData);
      const pageWidth = pdf.internal.pageSize.getWidth() - 20;
      const pdfHeight = (imgProps.height * pageWidth) / imgProps.width;
      pdf.addImage(imgData, 'PNG', 10, 20, pageWidth, pdfHeight);
      pdf.save(name + '.pdf');
    });
  } else {
    let csv = '';
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      const cols = row.querySelectorAll('td, th');
      csv += Array.from(cols).map(col => `"${col.textContent}"`).join(',') + '\n';
    });
    const blob = new Blob([csv], { type: 'text/csv' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = name + '.csv';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
}


function fillTables(data) {
  document.getElementById('tablesSection').style.display = 'block';
  const confirmed = [];
  const modified = [];
  const pending = [];

  data.forEach(row => {
    const status = row[9];
    const info = [row[4], row[1], row[5], row[6]];
    if (status === "ØªÙ… Ø§Ù„ØªØ£ÙƒÙŠØ¯") confirmed.push(info);
    else if (status === "Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©") modified.push(info);
    else pending.push(info);
  });

  const headers = ['#', 'Ø§Ø³Ù… Ø§Ù„Ù…Ø¯Ø±Ø³Ø©', 'Ø§Ù„Ù‚Ø·Ø§Ø¹', 'Ø§Ù„Ù…Ø¯ÙŠØ±/Ø©', 'Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆØ§Ù„'];
  createTable('confirmedTable', headers, confirmed);
  createTable('modifiedTable', headers, modified);
  createTable('pendingTable', headers, pending);

  document.getElementById("countConfirmed").textContent = "Ø§Ù„Ø¹Ø¯Ø¯: " + confirmed.length;
  document.getElementById("countModified").textContent = "Ø§Ù„Ø¹Ø¯Ø¯: " + modified.length;
  document.getElementById("countPending").textContent = "Ø§Ù„Ø¹Ø¯Ø¯: " + pending.length;
}

function createTable(id, headers, rows) {
  const table = document.getElementById(id);
  table.innerHTML = '';
  const thead = document.createElement('thead');
  const tr = document.createElement('tr');
  headers.forEach(h => {
    const th = document.createElement('th');
    th.textContent = h;
    tr.appendChild(th);
  });
  thead.appendChild(tr);
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  rows.forEach((row, idx) => {
    const tr = document.createElement('tr');
    const tdIndex = document.createElement('td');
    tdIndex.textContent = idx + 1;
    tr.appendChild(tdIndex);
    row.forEach(cell => {
      const td = document.createElement('td');
      td.textContent = cell;
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
}

</script>
</body>
</html>
